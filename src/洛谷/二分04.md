## 题目：
![01](./IMGS/01.png)

---

## 思路：
A-B=C  =>  B+C=A  /  A-C=B
A,B可以轻易得判断是否合理，故，把C当作已知，得到A或B，去寻找是否存在，若存在则计数。

---

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std; 

const int N=2e5+10; 
int a[N], n, c; 

int main(){
    ios::sync_with_stdio(0),  cin.tie(0);
    
    cin>>n>>c; 
    for(int i=1; i<=n; i++) cin>>a[i]; 
    sort(a+1, a+n+1); //有序
    long long ans=0; 
    for(int i=1; i<=n; i++){
        ans+=(upper_bound(a+1, a+n+1, a[i]+c)-a)-(lower_bound(a+1, a+n+1, a[i]+c)-a); 
    }
    cout<<ans<<'\n'; 
    return 0; 
}
```
> 思路：B+C=A 
寻找第一个符合B+C的A的下标和最后一个A的后一个下标，相减计入ans。 <ins>1</ins> 1 <ins>2</ins> 3 (ans+2)

---

## 代码：
```cpp
    #include <iostream>
    #include <map>
    using namespace std;
    typedef long long LL;
    LL a[200001];
    map<LL,LL> m; //建立一个数字到出现次数的映射 map<num,times>
    //A-B=C --> A-C=B
    int main() {
        int n;
        LL c;
        LL ans=0;
        cin >> n >> c;
        for(int i=1;i<=n;i++) {
            cin >> a[i];
            m[a[i]]++;
            a[i]-=c;  //A-C=B
        } 
        for(int i=1;i<=n;i++) ans+=m[a[i]];  //找合适的B，其数量累加
        cout << ans << '\n';
        return 0;
}

```

---

## 代码：
```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int N = 2e5 + 10;
int n , c;
int a[N];

int main () 
{
	cin >> n >> c;
	for(int i = 1 ; i <= n ; i ++) cin >> a[i];
	sort(a + 1 , a + 1 + n);
	int l = 1, r1 = 1 , r2 = 1;
	ll ans = 0;
	for(l = 1 ; l <= n ; l ++) {
		while(r1 <= n && a[r1] - a[l] <= c) r1 ++;  //upper_bound
		while(r2 <= n && a[r2] - a[l] < c ) r2 ++;  //lower_bound
		if(a[r2] - a[l] == c && a[r1 - 1] - a[l] == c && r1 - 1 >= 1) 	
			ans += r1 - r2;
	}
	cout << ans;
	return 0;
}
```

> 思路，方法一的双指针版本--找左右端点
